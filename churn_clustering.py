# -*- coding: utf-8 -*-
"""BaseEControleDeClientes_RômuloValle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11GveqapMhojgEfKuybKS-CoNH79PdJKf

# Base Clientes IMG
"""



# leitura das lib
import pyodbc
import pandas as pd
import math
from pandas.tseries.offsets import MonthEnd
#import boto3
#import datetime
#import time
#from dateutil.relativedelta import relativedelta
#import json
import plotly.express as px
# Import the necessaries libraries
import plotly.offline as pyo
#import plotly.graph_objs as go
#import matplotlib.pyplot as plt
#import squarify

"""## Preparação dos Dados"""

# puxa os dados de todas as vendas feitas no ecommerce junto com a identificação do cliente
# Lembrar sempre de alterar a data limite na Query de Franquias e de Ecommerce

query = """
SELECT [CODIGO_FILIAL]
      ,[TICKET] AS PEDIDO
      ,CANAL = 'LOJA'
      ,OMNI = ''
      ,[DATA_VENDA] AS EMISSAO
      ,[CODIGO_CLIENTE] AS CPF
      ,[VALOR_PAGO] AS VALOR
FROM [ERP_Franquias].[dbo].[LOJA_VENDA] (NOLOCK)
WHERE DATA_VENDA >= '2019-01-01' AND DATA_VENDA < '2022-06-01'
UNION ALL
SELECT CODIGO_FILIAL = '999999',
       CAST(T1.PEDIDO AS varchar) AS PEDIDO,
       CANAL = 'ECM',
       T1.OMNI,
       T1.EMISSAO,
       T2.CPF,
       T1.VALOR_TOTAL AS VALOR
FROM [Int_IMGSys].[dbo].[IMG_ECM_LOJA_PEDIDO] AS T1
INNER JOIN [Int_IMGSys].[dbo].[IMG_ECM_CLIENTES_VAREJO] AS T2
    ON T1.PEDIDO = T2.PEDIDO
WHERE T1.EMISSAO >= '2019-01-01' AND T1.EMISSAO < '2022-06-01' AND T1.ORIGEM_PEDIDO = 'IMAGINARIUM'
"""

pedidos = pd.read_sql(query, conn)



conn.close

pedidos.head()

"""### Interação"""

# tira quantidade zero e preco negativo
pedidos = pedidos.loc[pedidos['VALOR']>1]

# tira nao numero do cpf
pedidos['CPF'] = pedidos['CPF'].str.extract('(\d+)')

pedidos['ID'] = pedidos['CODIGO_FILIAL'] + pedidos['PEDIDO']

"""#### Verifica volume de CPF informados"""

pedidos.groupby('CANAL')['ID'].nunique()

pedidos.groupby('CANAL')['CPF'].nunique()

# valida os cpf da base
def validar_cpf(cpf):

    """ Efetua a validação do CPF, tanto formatação quando dígito verificadores.

    Parâmetros:
        cpf (str): CPF a ser validado

    Retorno:
        bool:
            - Falso, quando o CPF não possuir 11 caracteres numéricos;
            - Falso, quando os dígitos verificadores forem inválidos;
            - Verdadeiro, caso contrário.
    """

    # se vazio falso
    if math.isnan(float(cpf)):
        return False

    # Obtém apenas os números do CPF, ignorando pontuações
    numbers = [int(digit) for digit in cpf if digit.isdigit()]

    # Verifica se o CPF possui 11 números:
    if len(numbers) != 11:
        return False

    # Verifica se é todo repetido
    lista_repetido = ["00000000000", "11111111111", "22222222222", "33333333333", "44444444444", "55555555555", "66666666666", "77777777777", "88888888888", "99999999999"]
    if cpf in lista_repetido:
        return False

    # Validação do primeiro dígito verificador:
    sum_of_products = sum(a*b for a, b in zip(numbers[0:9], range(10, 1, -1)))
    expected_digit = (sum_of_products * 10 % 11) % 10
    if numbers[9] != expected_digit:
        return False

    # Validação do segundo dígito verificador:
    sum_of_products = sum(a*b for a, b in zip(numbers[0:10], range(11, 1, -1)))
    expected_digit = (sum_of_products * 10 % 11) % 10
    if numbers[10] != expected_digit:
        return False

    return True

# aplica funcao de validar CPF por numero de digitos e digito verificador
pedidos['cpf_valido'] = pedidos['CPF'].apply(validar_cpf)
pedidos = pedidos.loc[pedidos['cpf_valido']].drop(['cpf_valido'], axis=1)

"""#### Verifica volume de CPF válidos informados"""

pedidos.groupby('CANAL')['ID'].nunique()

pedidos.groupby('CANAL')['CPF'].nunique()

pedido_out = pedidos.groupby(['EMISSAO','CPF'], as_index=False).agg({'PEDIDO': pd.Series.nunique})

cpf_out = pedido_out.loc[pedido_out['PEDIDO']>4]['CPF'].drop_duplicates().to_list()

pedidos = pedidos.loc[~pedidos['CPF'].isin(cpf_out)]

"""#### Verifica volume de CPF válidos informados excluindo vendedores"""

pedidos.groupby('CANAL')['ID'].nunique()

pedidos.groupby('CANAL')['CPF'].nunique()

# Clientes dos dois canais
sum(pedidos.groupby('CPF')['CANAL'].nunique() > 1)

pedidos.shape

"""#### Clientes por mês e segmentação de compras"""

pedido_mtbp = pedidos.copy()

pedido_mtbp['DIFF'] = pedido_mtbp.sort_values(['CANAL', 'CPF', 'EMISSAO']).groupby(['CANAL', 'CPF'])['EMISSAO'].diff().dt.days
pedido_mtbp.loc[pedido_mtbp['DIFF'].isna(), 'TIPO_CLIENTE'] = 'Novo'
pedido_mtbp.loc[pedido_mtbp['DIFF'] <= 365, 'TIPO_CLIENTE'] = 'Ativo'
pedido_mtbp.loc[pedido_mtbp['DIFF'] > 365, 'TIPO_CLIENTE'] = 'Recuperado'

aggregations = {'CPF': 'count',
                'VALOR': 'sum'}

pedido_mtbp

cliente_dia = pedido_mtbp.groupby(['CANAL', 'EMISSAO', 'TIPO_CLIENTE'], as_index=False).agg(aggregations)

cliente_dia = cliente_dia.pivot_table(index=['CANAL', 'EMISSAO'],
                                                  columns='TIPO_CLIENTE',
                                                  values=['CPF', 'VALOR'])

churn = pedidos.copy()
churn['MES_COMPRA'] = churn['EMISSAO'].dt.to_period('M')
churn['PRIMEIRA_COMPRA'] = churn.groupby(['CPF', 'CANAL'])['EMISSAO'].transform('min')
churn['MES_PRIMEIRA_COMPRA'] = churn.groupby(['CPF', 'CANAL'])['EMISSAO'].transform('min').dt.to_period('M')

churn

intervalo = churn[['MES_COMPRA', 'CANAL']].drop_duplicates()
intervalo.columns = ['MES_REF', 'CANAL']

intervalo

intervalo['MES_INICIO'] = intervalo['MES_REF'] - 12

intervalo = intervalo.loc[intervalo['MES_INICIO'] >= min(intervalo['MES_REF'])]

churn = pd.merge(intervalo, churn, on=['CANAL'], how='outer')
churn = churn.loc[(churn['MES_COMPRA'] >= churn['MES_INICIO']) & (churn['MES_COMPRA'] <= churn['MES_REF'])]

aggregations = {
                'VALOR': 'sum',
                'PEDIDO': 'count',
                'EMISSAO': ['min', 'max'],
                'PRIMEIRA_COMPRA': 'min'
            }

churn = churn.groupby(['CANAL', 'CPF', 'MES_REF'], as_index=False).agg(aggregations)

churn.columns = ['CANAL', 'CPF', 'MES_REF', 'VALOR', 'PEDIDO', 'EMISSAO_MIN', 'EMISSAO_MAX', 'PRIMEIRA_COMPRA']

churn['DATA_REF'] = pd.to_datetime(churn['MES_REF'].dt.strftime('%Y-%m'), format="%Y-%m") + MonthEnd(1)

churn

churn.loc[churn['EMISSAO_MAX'] >= churn['DATA_REF'] - pd.to_timedelta(90, unit='d'), 'TIPO_CLIENTE'] = 'Até 90 dias'
churn.loc[churn['EMISSAO_MAX'] < churn['DATA_REF'] - pd.to_timedelta(90, unit='d'), 'TIPO_CLIENTE'] = 'Até 1 ano'
churn.loc[churn['EMISSAO_MAX'] < churn['DATA_REF'] - pd.to_timedelta(365, unit='d'), 'TIPO_CLIENTE'] = 'Churn'
churn.loc[churn['PRIMEIRA_COMPRA'].dt.to_period('M') == churn['MES_REF'], 'TIPO_CLIENTE'] = 'Novo'

base_cli = churn.groupby(['MES_REF','CANAL', 'TIPO_CLIENTE'], as_index=False)[['CPF']].count()

base_vendas = churn.groupby(['MES_REF','CANAL', 'TIPO_CLIENTE'], as_index=False)[['VALOR']].sum()

base_freq = churn.groupby(['MES_REF','CANAL', 'TIPO_CLIENTE'], as_index=False)[['PEDIDO']].sum()

base_cli.to_excel('BaseClientesIMG.xlsx')

base_cli

base_cli['RECEITA'] = base_vendas['VALOR']

base_cli

base_TM = churn.groupby(['MES_REF','CANAL'], as_index=False)[['PEDIDO', 'VALOR']].sum()
base_TM['TICKET MÉDIO'] = base_TM['VALOR'] / base_TM['PEDIDO']
base_TM.drop('PEDIDO', axis=1, inplace=True)
base_TM.drop('VALOR', axis=1, inplace=True)

base_cli['PEDIDO'] = base_freq['PEDIDO']
base_cli['FREQ MEDIA'] = base_cli['PEDIDO'] / base_cli['CPF']
base_freqmedia = base_cli.groupby(['MES_REF'], as_index=False)[['FREQ MEDIA']].mean()

base_cli

base_cli.to_excel('mindrevisao.xlsx')

pivot_plot = pd.pivot_table(data=base_cli, index=['MES_REF'], columns=['TIPO_CLIENTE'], values='CPF')

ax = pivot_plot.plot.bar(stacked=True, figsize=(15,4))
ax.set_ylabel('Clientes')
ax.set_xlabel('Meses')
ax.set_title('Acompanhamento da Base de Clientes Imaginarium')
labels = [f'{i}' for i in pivot_plot.to_numpy().flatten(order='F')]

for i, patch in enumerate(ax.patches):
    x, y = patch.get_xy()
    x += patch.get_width() / 2
    y += patch.get_height() / 2
    ax.annotate(labels[i], (x, y), ha='center', va='center', c='black')

pivot_plot_valor = pd.pivot_table(data=base_cli, index=['MES_REF'], columns=['TIPO_CLIENTE'], values='RECEITA')

ax_2 = pivot_plot_valor.plot.bar(stacked=True, figsize=(15,4))
ax.set_ylabel('Clientes')
ax.set_xlabel('Meses')
ax.set_title('Acompanhamento da Base de Clientes Imaginarium')
labels = [f'{i}' for i in pivot_plot_valor.to_numpy().flatten(order='F')]

for i, patch in enumerate(ax.patches):
    x, y = patch.get_xy()
    x += patch.get_width() / 2
    y += patch.get_height() / 2
    ax.annotate(labels[i], (x, y), ha='center', va='center', c='black')



